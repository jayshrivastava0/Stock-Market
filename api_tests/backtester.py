#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Backtesting Engine Core Module

Provides a robust and extensible framework for simulating trading strategies
against historical market data. It focuses on accurate state management (cash,
holdings), realistic order execution simulation (including commissions), and
detailed performance tracking, adhering to production-level code standards.
"""

import logging
from datetime import date, datetime
from typing import (Dict, List, Optional, Tuple, Union, Type, Any, TypeAlias,
                    Final, Set)
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
import re

import pandas as pd
import numpy as np

# --- Type Aliases ---
# For clarity in type hints
Timestamp: TypeAlias = pd.Timestamp
DateLike: TypeAlias = Union[str, date, datetime, Timestamp]
TickerSymbol: TypeAlias = str
HoldingsDict: TypeAlias = Dict[TickerSymbol, int]


# --- Setup Logging ---
# Configure logger for this module. Relies on application-level configuration.
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


# --- Constants ---
# Standard column names expected/used within the backtester
OPEN: Final[str] = 'Open'
HIGH: Final[str] = 'High'
LOW: Final[str] = 'Low'
CLOSE: Final[str] = 'Close'
VOLUME: Final[str] = 'Volume'
# Ensure consistency with data_handler's definition
OHLCV_COLS: Final[List[str]] = [OPEN, HIGH, LOW, CLOSE, VOLUME]

# Internal column names for equity curve
CASH_COL: Final[str] = 'Cash'
HOLDINGS_VALUE_COL: Final[str] = 'Holdings_Value'
TOTAL_EQUITY_COL: Final[str] = 'Total_Equity'

# Order actions
BUY_ACTION: Final[str] = 'BUY'
SELL_ACTION: Final[str] = 'SELL'
VALID_ACTIONS: Final[Set[str]] = {BUY_ACTION, SELL_ACTION}

# Default execution/valuation columns
DEFAULT_EXECUTION_PRICE_COL: Final[str] = OPEN
DEFAULT_VALUATION_PRICE_COL: Final[str] = CLOSE

# --- Dependency: Data Handler ---
try:
    from data_handler import (
        fetch_stock_data,
        # Potentially reuse validation helpers if made public in data_handler
        # _validate_date_input,
        # _clean_ticker_list,
        DataFetchError as DH_DataFetchError,
        InvalidInputError as DH_InvalidInputError,
        DataProcessingError as DH_DataProcessingError,
        DataHandlerError as DH_DataHandlerError
    )
except ImportError as e:
    log.critical(
        "Fatal Error: Could not import from data_handler module. "
        "Ensure 'data_handler.py' is installed or accessible in the Python path.",
        exc_info=True
    )
    # Propagate as a standard ImportError to halt execution if critical
    raise ImportError("Missing required dependency: data_handler module") from e

# --- Custom Exceptions ---
# Hierarchical exceptions for better error handling context
class BacktesterError(Exception):
    """Base exception for errors specific to the backtester module."""
    pass

class ConfigError(BacktesterError, ValueError):
    """Exception raised for invalid configuration or initialization parameters."""
    pass

class DataError(BacktesterError):
    """
    Exception raised for issues related to market data required for the backtest.
    This includes fetching failures, missing data, or unexpected formats.
    """
    pass

class ExecutionError(BacktesterError):
    """Base exception for errors during the simulation of trade execution."""
    pass

class InsufficientFundsError(ExecutionError):
    """Raised when a buy order cannot be executed due to lack of cash."""
    def __init__(self, ticker: TickerSymbol, quantity: int, needed: float, available: float):
        self.ticker = ticker
        self.quantity = quantity
        self.needed = needed
        self.available = available
        super().__init__(
            f"Insufficient funds to buy {quantity} {ticker}. "
            f"Needed: {needed:.2f}, Available: {available:.2f}"
        )

class InsufficientHoldingsError(ExecutionError):
    """Raised when a sell order cannot be executed due to lack of shares."""
    def __init__(self, ticker: TickerSymbol, needed: int, available: int):
        self.ticker = ticker
        self.needed = needed
        self.available = available
        super().__init__(
            f"Insufficient holdings to sell {needed} {ticker}. "
            f"Needed: {needed}, Available: {available}"
        )

class StrategyError(BacktesterError):
    """
    Exception raised for errors originating within the user-provided strategy logic
    during signal generation.
    """
    pass

# --- Supporting Data Structures ---

@dataclass(frozen=True) # Immutable orders once created
class Order:
    """
    Represents a trading order generated by a strategy.

    Attributes:
        ticker: The stock ticker symbol.
        action: The order action ('BUY' or 'SELL').
        quantity: The number of shares to trade (must be positive).
    """
    ticker: TickerSymbol
    action: str
    quantity: int

    def __post_init__(self):
        """Validate order attributes after initialization."""
        if not self.ticker or not isinstance(self.ticker, str):
            raise ConfigError("Order ticker must be a non-empty string.")
        if self.action not in VALID_ACTIONS:
            raise ConfigError(f"Order action '{self.action}' is invalid. Use {VALID_ACTIONS}.")
        if not isinstance(self.quantity, int) or self.quantity <= 0:
            raise ConfigError("Order quantity must be a positive integer.")

@dataclass(frozen=True) # Immutable trade records
class Trade:
    """
    Represents an executed trade recorded by the backtester.

    Attributes:
        timestamp: The date and time the trade was executed.
        ticker: The stock ticker symbol involved.
        action: The action performed ('BUY' or 'SELL').
        quantity: The number of shares traded.
        price: The execution price per share.
        commission: The commission amount charged for the trade.
        cost_proceeds: The net cash impact (negative for buys, positive for sells).
        cash_after: The cash balance immediately after the trade.
        holdings_after: A snapshot of the portfolio holdings after the trade.
    """
    timestamp: Timestamp
    ticker: TickerSymbol
    action: str
    quantity: int
    price: float
    commission: float
    cost_proceeds: float
    cash_after: float
    holdings_after: HoldingsDict # Store a copy


class CommissionModel(ABC):
    """Abstract base class for commission calculation models."""

    @abstractmethod
    def calculate(self, quantity: int, price: float) -> float:
        """
        Calculates the commission for a single trade.

        Args:
            quantity: The number of shares traded.
            price: The price per share.

        Returns:
            The calculated commission amount (must be non-negative).

        Raises:
            ValueError: If inputs (quantity, price) are invalid for calculation.
        """
        pass


@dataclass(frozen=True)
class BasicCommission(CommissionModel):
    """
    A simple commission model with optional fixed and percentage fees.

    Attributes:
        fixed_fee: A fixed cost applied to every trade (>= 0).
        percent_fee: A fee calculated as a percentage of the trade's value (>= 0).
                     Example: 0.001 represents 0.1%.
    """
    fixed_fee: float = 0.0
    percent_fee: float = 0.0

    def __post_init__(self):
        """Validate commission parameters."""
        if self.fixed_fee < 0:
            raise ConfigError("Fixed commission fee cannot be negative.")
        if self.percent_fee < 0:
            raise ConfigError("Percentage commission fee cannot be negative.")

    def calculate(self, quantity: int, price: float) -> float:
        """
        Calculates commission based on fixed and percentage fees.

        Args:
            quantity: The number of shares traded.
            price: The price per share.

        Returns:
            The total commission amount.

        Raises:
            ValueError: If quantity or price is non-positive (invalid trade value).
        """
        if quantity <= 0 or price <= 0:
            # A trade with zero quantity or price should ideally not occur,
            # but if it does, commission calculation needs careful handling.
            # Returning 0 seems reasonable as no value is exchanged.
            # Alternatively, raise ValueError if this state is unexpected.
            log.warning(
                f"Commission calculation called with non-positive inputs "
                f"(qty={quantity}, price={price}). Returning 0 commission."
            )
            return 0.0
            # raise ValueError("Quantity and price must be positive for commission calculation.")

        trade_value = abs(quantity * price) # Use abs value? No, quantity * price represents value flow
        trade_value = quantity * price # Revert, use direct value
        commission = self.fixed_fee + (trade_value * self.percent_fee)
        return max(0.0, commission) # Ensure commission isn't negative due to float issues


# --- Strategy Interface (Abstract Base Class) ---

class Strategy(ABC):
    """
    Abstract interface for all trading strategies used by the Backtester.

    Strategies must implement the `generate_signals` method, which contains
    the core logic for deciding trades based on historical data and current
    portfolio state. Strategies should operate only on data available up to
    the current simulation time to avoid lookahead bias.
    """

    def __init__(self, parameters: Optional[Dict[str, Any]] = None):
        """
        Initializes the strategy.

        Args:
            parameters (Optional[Dict[str, Any]]): A dictionary of parameters
                to configure the strategy's behavior. Defaults to None.
        """
        self.parameters: Final[Dict[str, Any]] = parameters if parameters else {}
        log.info(f"Initialized strategy {self.__class__.__name__} with params: {self.parameters}")
        self._validate_parameters()


    def _validate_parameters(self) -> None:
        """
        Optional method for strategies to validate their specific parameters.
        Should raise ConfigError if parameters are invalid.
        """
        # Default implementation does nothing. Subclasses should override.
        pass


    @abstractmethod
    def generate_signals(
        self,
        current_dt: Timestamp,
        data_slice: pd.DataFrame,
        current_holdings: HoldingsDict,
        current_cash: float
    ) -> List[Order]:
        """
        Generates trading signals (orders) for the current time step.

        This method encapsulates the strategy's decision-making logic. It must
        return a list of `Order` objects based *only* on the information
        provided in the arguments.

        Args:
            current_dt (Timestamp): The current timestamp in the backtest simulation.
                Represents the point in time *after* which generated orders
                would hypothetically be placed.
            data_slice (pd.DataFrame): DataFrame containing historical market data
                (OHLCV, typically MultiIndex columns) for all tickers up to and
                *including* `current_dt`. The index is a DatetimeIndex.
            current_holdings (HoldingsDict): A *copy* of the portfolio's current
                holdings (ticker -> quantity) *before* considering any new orders
                for `current_dt`.
            current_cash (float): The current available cash balance *before*
                considering any new orders for `current_dt`.

        Returns:
            List[Order]: A list of `Order` objects representing the trades the
            strategy wants to execute, typically effective at the start of the
            *next* time step (as simulated by the backtester using `dt`).
            Return an empty list if no trades are desired.

        Raises:
            StrategyError: Subclasses should wrap internal exceptions in
                           StrategyError to clearly indicate the source of failure.
        """
        pass


# --- Backtester Engine ---

class Backtester:
    """
    Core engine for simulating a trading strategy over historical market data.

    This class orchestrates the simulation by:
    1. Fetching and preparing historical market data.
    2. Iterating through time steps (typically daily).
    3. Calling the provided strategy to generate trading signals.
    4. Simulating order execution, considering cash, holdings, and commissions.
    5. Tracking portfolio state (cash, holdings, total equity) over time.
    6. Recording executed trades.
    """

    def __init__(
        self,
        initial_capital: float,
        tickers: List[TickerSymbol],
        strategy_class: Type[Strategy],
        start_date: DateLike,
        end_date: DateLike,
        strategy_params: Optional[Dict[str, Any]] = None,
        commission_model: CommissionModel = BasicCommission(),
        data_handler_params: Optional[Dict[str, Any]] = None,
        execution_price_col: str = DEFAULT_EXECUTION_PRICE_COL,
        valuation_price_col: str = DEFAULT_VALUATION_PRICE_COL,
        data_fetch_func: callable = fetch_stock_data, # Allow injection
    ):
        """
        Initializes the Backtester engine.

        Args:
            initial_capital: The starting cash amount for the simulation (must be > 0).
            tickers: A list of stock ticker symbols to include in the simulation.
            strategy_class: The class of the strategy to use (must inherit from `Strategy`).
            start_date: The starting date for fetching historical data. Supports
                'YYYY-MM-DD' string format, date/datetime objects.
            end_date: The ending date for fetching historical data. Supports
                'YYYY-MM-DD' string format, date/datetime objects, or 'today'.
            strategy_params (Optional[Dict[str, Any]]): Dictionary of parameters to
                pass to the strategy's constructor. Defaults to None.
            commission_model (CommissionModel): An instance of a commission model
                to calculate trade costs. Defaults to `BasicCommission()`.
            data_handler_params (Optional[Dict[str, Any]]): Additional parameters to pass
                to the underlying data fetch function (`fetch_stock_data` by default).
                Defaults to None.
            execution_price_col (str): The OHLCV column name to use for simulating
                the price at which trades are executed. Defaults to 'Open'.
            valuation_price_col (str): The OHLCV column name to use for calculating
                the market value of holdings at the end of each time step.
                Defaults to 'Close'.
            data_fetch_func (callable): The function used to fetch historical stock data.
                Defaults to `data_handler.fetch_stock_data`. Allows dependency injection
                for testing or using alternative data sources.

        Raises:
            ConfigError: If any initialization parameters are invalid (e.g.,
                negative capital, empty ticker list, invalid dates, invalid price
                column names, strategy class not subclass of `Strategy`).
            TypeError: If `strategy_class` is not a class or not derived from `Strategy`.
        """
        log.info("Initializing Backtester instance...")

        self._validate_init_params(
            initial_capital, tickers, strategy_class, start_date, end_date,
            commission_model, execution_price_col, valuation_price_col,
            data_fetch_func
        )

        self.initial_capital: Final[float] = initial_capital
        self.tickers: Final[List[TickerSymbol]] = self._clean_tickers(tickers)
        self.start_date_input: Final[DateLike] = start_date
        self.end_date_input: Final[DateLike] = end_date
        self.commission_model: Final[CommissionModel] = commission_model
        self.data_handler_params: Final[Optional[Dict[str, Any]]] = data_handler_params
        self.execution_price_col: Final[str] = execution_price_col
        self.valuation_price_col: Final[str] = valuation_price_col
        self.data_fetch_func: Final[callable] = data_fetch_func

        # Instantiate the strategy - catch specific init errors if strategy raises them
        try:
             self.strategy: Final[Strategy] = strategy_class(strategy_params)
        except ConfigError as e: # Catch config errors from strategy's _validate_parameters
            log.error(f"Strategy '{strategy_class.__name__}' configuration failed: {e}", exc_info=True)
            raise ConfigError(f"Strategy configuration error: {e}") from e
        except Exception as e: # Catch unexpected errors during strategy init
            log.error(f"Unexpected error initializing strategy '{strategy_class.__name__}': {e}", exc_info=True)
            raise ConfigError(f"Failed to initialize strategy: {e}") from e


        # Internal state variables, initialized before run()
        self._cash: float = 0.0
        self._holdings: HoldingsDict = {}
        self._market_data: Optional[pd.DataFrame] = None
        self._equity_curve: Optional[pd.DataFrame] = None
        self._trades: List[Trade] = []
        self._current_dt: Optional[Timestamp] = None # Current simulation timestamp

        self._actual_start_date: Optional[date] = None # Set after data fetch
        self._actual_end_date: Optional[date] = None   # Set after data fetch

        log.info(f"Backtester initialized successfully for tickers: {self.tickers}")
        log.info(f"Requested Period: {self._format_date_for_log(start_date)} to "
                 f"{self._format_date_for_log(end_date)}")
        log.info(f"Strategy: {strategy_class.__name__}")
        log.info(f"Execution Price: '{execution_price_col}', Valuation Price: '{valuation_price_col}'")

    def _validate_init_params(self, *args) -> None:
        """Performs detailed validation of constructor arguments."""
        (initial_capital, tickers, strategy_class, start_date, end_date,
         commission_model, exec_col, val_col, fetch_func) = args

        if not isinstance(initial_capital, (int, float)) or initial_capital <= 0:
            raise ConfigError("Initial capital must be a positive number.")
        if not tickers or not isinstance(tickers, list) or not all(isinstance(t, str) and t.strip() for t in tickers):
            raise ConfigError("Tickers must be a non-empty list of non-empty strings.")
        if not isinstance(strategy_class, type) or not issubclass(strategy_class, Strategy):
            raise ConfigError("strategy_class must be a class derived from Strategy.")
        if not isinstance(start_date, (str, date, datetime, Timestamp)) or not start_date:
             raise ConfigError("start_date must be a non-empty string, date, or datetime object.")
        if not isinstance(end_date, (str, date, datetime, Timestamp)) or not end_date:
             raise ConfigError("end_date must be a non-empty string, date, or datetime object.")
        if not isinstance(commission_model, CommissionModel):
            raise ConfigError("commission_model must be an instance of CommissionModel.")
        if not isinstance(exec_col, str) or exec_col not in OHLCV_COLS:
            raise ConfigError(f"Execution price column '{exec_col}' must be one of {OHLCV_COLS}")
        if not isinstance(val_col, str) or val_col not in OHLCV_COLS:
            raise ConfigError(f"Valuation price column '{val_col}' must be one of {OHLCV_COLS}")
        if not callable(fetch_func):
            raise ConfigError("data_fetch_func must be a callable function.")
        # Date format validation will happen during _prepare_run or data fetch
        log.debug("Initialization parameters basic validation passed.")

    def _clean_tickers(self, tickers: List[str]) -> List[TickerSymbol]:
        """Cleans and sorts the input ticker list."""
        cleaned = sorted({t.upper().strip() for t in tickers if t and t.strip()})
        if not cleaned:
            raise ConfigError("Ticker list is empty after cleaning.")
        return cleaned

    def _format_date_for_log(self, dt_input: DateLike) -> str:
        """Formats various date inputs consistently for logging."""
        if isinstance(dt_input, str):
            return dt_input # Keep original string representation
        elif isinstance(dt_input, (datetime, Timestamp, date)):
            return dt_input.strftime('%Y-%m-%d')
        return str(dt_input) # Fallback

    def _validate_date_str(self, date_str: str, param_name: str) -> date:
        """Validates date string format and value."""
        # Basic check - stricter parsing can be added if needed
        match = re.match(r'^(\d{4})-(\d{2})-(\d{2})$', date_str)
        if not match:
            raise ConfigError(f"Invalid date format for {param_name} '{date_str}'. Expected 'YYYY-MM-DD'.")
        try:
            year, month, day = map(int, match.groups())
            return date(year, month, day)
        except ValueError as e:
            raise ConfigError(f"Invalid date value for {param_name} '{date_str}'. {e}") from e

    def _prepare_run(self) -> Tuple[str, str]:
        """
        Prepares dates for data fetching and validates them.
        Returns validated start and end date strings in 'YYYY-MM-DD' format.
        """
        start_str: str
        end_str: str

        if isinstance(self.start_date_input, str):
            start_obj = self._validate_date_str(self.start_date_input, "start_date")
            start_str = self.start_date_input
        elif isinstance(self.start_date_input, (datetime, Timestamp)):
            start_obj = self.start_date_input.date()
            start_str = start_obj.strftime('%Y-%m-%d')
        elif isinstance(self.start_date_input, date):
            start_obj = self.start_date_input
            start_str = start_obj.strftime('%Y-%m-%d')
        else: # Should be caught by init validation
            raise ConfigError("Internal error: Invalid start_date type.")

        today = date.today()
        if isinstance(self.end_date_input, str):
            if self.end_date_input.lower() == 'today':
                end_obj = today
                end_str = end_obj.strftime('%Y-%m-%d')
            else:
                end_obj = self._validate_date_str(self.end_date_input, "end_date")
                end_str = self.end_date_input
        elif isinstance(self.end_date_input, (datetime, Timestamp)):
            end_obj = self.end_date_input.date()
            end_str = end_obj.strftime('%Y-%m-%d')
        elif isinstance(self.end_date_input, date):
            end_obj = self.end_date_input
            end_str = end_obj.strftime('%Y-%m-%d')
        else: # Should be caught by init validation
            raise ConfigError("Internal error: Invalid end_date type.")

        # Chronological check
        if start_obj > end_obj:
            raise ConfigError(f"Start date {start_str} cannot be after end date {end_str}.")

        log.debug(f"Date preparation completed. Fetch range: {start_str} to {end_str}")
        return start_str, end_str


    def _fetch_data(self) -> None:
        """
        Fetches historical OHLCV data using the configured data fetch function.

        Raises:
            DataError: If fetching fails, data is empty, incorrectly formatted,
                       or missing required columns for configured tickers.
            ConfigError: If date inputs are invalid.
        """
        log.info(f"Attempting to fetch market data for {len(self.tickers)} tickers...")
        try:
            start_str, end_str = self._prepare_run()
        except ConfigError as e:
            log.error(f"Date validation failed before fetching data: {e}")
            raise # Re-raise ConfigError

        try:
            # Fetch RAW OHLCV data. Adjustments handled by strategy if needed.
            # Explicitly use_adj_close=False ensures raw prices.
            data: pd.DataFrame = self.data_fetch_func(
                tickers=self.tickers,
                start_date_str=start_str,
                end_date_str=end_str,
                use_adj_close=False, # Crucial for simulation on raw prices
                yf_download_params=self.data_handler_params
            )
            log.info(f"Data fetch function completed. Initial data shape: {data.shape}")

        except DH_InvalidInputError as e:
             log.error(f"Invalid input provided to data fetch function: {e}", exc_info=True)
             raise ConfigError(f"Invalid parameters for data fetching: {e}") from e
        except (DH_DataFetchError, DH_DataProcessingError) as e:
             log.error(f"Data fetching/processing failed via data handler: {e}", exc_info=True)
             raise DataError(f"Failed to retrieve or process market data: {e}") from e
        except DH_DataHandlerError as e: # Catch base class for unexpected handler issues
             log.error(f"An unexpected error occurred in the data handler: {e}", exc_info=True)
             raise DataError(f"Unexpected data handler error: {e}") from e
        except Exception as e:
             log.exception("An unexpected error occurred during the call to data fetch function.")
             raise BacktesterError("Unexpected error during data fetch operation.") from e


        # --- Post-Fetch Validation ---
        if data.empty:
            log.error("Fetched market data is empty for the specified tickers and date range.")
            raise DataError("No market data returned for the requested parameters.")

        if not isinstance(data.index, pd.DatetimeIndex):
             log.error(f"Market data index type is {type(data.index)}, expected DatetimeIndex.")
             raise DataError("Market data index is not a DatetimeIndex.")
        if data.index.tz is not None:
             log.error("Market data index is timezone-aware. Backtester requires timezone-naive.")
             # Potentially add conversion here if feasible, but usually safer to fix upstream.
             raise DataError("Market data index must be timezone-naive.")

        if not isinstance(data.columns, pd.MultiIndex):
            log.error(f"Market data columns are not MultiIndex (found {type(data.columns)}). "
                      "Expected format: ('OHLCV', 'TICKER').")
            raise DataError("Market data columns have unexpected format.")
        if data.columns.nlevels != 2:
             log.error(f"Market data column MultiIndex has {data.columns.nlevels} levels, expected 2.")
             raise DataError("Market data columns have unexpected format (level count).")


        # Verify required price columns exist for *all* requested tickers
        missing_cols = []
        present_tickers = set(data.columns.get_level_values(1)) # Tickers actually in the data
        required_level_0 = {self.execution_price_col, self.valuation_price_col}.union(OHLCV_COLS) # All needed level 0 names

        # Check 1: Are all required *types* of columns present (e.g., 'Open', 'Close')?
        present_level_0 = set(data.columns.get_level_values(0))
        missing_level_0 = required_level_0 - present_level_0
        if missing_level_0:
             raise DataError(f"Market data is missing essential column types: {sorted(list(missing_level_0))}")

        # Check 2: Are required columns present for *each* requested ticker?
        for ticker in self.tickers:
            if ticker not in present_tickers:
                log.warning(f"Data for ticker '{ticker}' was requested but not returned by fetch function.")
                # Decide if this is fatal. Often ok to proceed if some tickers are missing,
                # but it depends on the strategy. Let's warn for now. Strategy should handle this.
                continue # Check next ticker

            # Check execution price column for this ticker
            exec_key = (self.execution_price_col, ticker)
            if exec_key not in data.columns:
                missing_cols.append(f"'{self.execution_price_col}' for {ticker}")

            # Check valuation price column for this ticker
            val_key = (self.valuation_price_col, ticker)
            if val_key not in data.columns:
                 missing_cols.append(f"'{self.valuation_price_col}' for {ticker}")

        if missing_cols:
             log.error(f"Market data is missing required price columns for specific tickers: "
                       f"{', '.join(missing_cols)}")
             raise DataError("Market data incomplete. Missing required price columns.")

        self._market_data = data
        self._actual_start_date = data.index.min().date()
        self._actual_end_date = data.index.max().date()
        log.info(f"Market data fetched and validated successfully.")
        log.info(f"Actual data range available: {self._actual_start_date} to {self._actual_end_date}")


    def _execute_order(self, dt: Timestamp, order: Order) -> bool:
        """
        Simulates the execution of a single order at a specific time `dt`.

        Updates cash and holdings based on the execution price and commission.
        Records the executed trade if successful. Handles insufficient funds/holdings
        by logging a warning and returning False (does not raise ExecutionError here).

        Args:
            dt: The timestamp representing the moment of execution (price lookup).
            order: The Order object to attempt execution for.

        Returns:
            bool: True if the order was successfully executed, False otherwise
                  (e.g., due to missing price, insufficient funds/holdings).

        Raises:
            DataError: If the execution price data is fundamentally missing or
                       malformed in the market data structure for the given dt/ticker,
                       indicating a critical data integrity issue.
        """
        ticker = order.ticker
        action = order.action
        quantity = order.quantity # Assumed positive by Order.__post_init__

        log.debug(f"[{dt.date()}] Attempting order: {action} {quantity} {ticker}")

        # --- Get Execution Price ---
        price_col_key = (self.execution_price_col, ticker)
        try:
            # Using .at for performance on single value lookup
            price = self._market_data.at[dt, price_col_key]
        except KeyError:
            # Should not happen if _fetch_data validation passed, indicates deeper issue.
            log.error(f"[{dt.date()}] CRITICAL: Execution price column {price_col_key} "
                      f"not found for date {dt}. Data integrity issue?")
            raise DataError(f"Execution price data structurally missing for {ticker} on {dt.date()}")
        except Exception as e:
            # Catch other unexpected lookup errors
            log.exception(f"[{dt.date()}] Unexpected error fetching execution price "
                          f"for {ticker}: {e}")
            raise DataError(f"Unexpected error getting price for {ticker} on {dt.date()}") from e

        # Validate the fetched price
        if pd.isna(price) or price <= 0:
            # Treat missing or non-positive price as non-executable
            log.warning(
                f"[{dt.date()}] Order execution skipped: Invalid or missing "
                f"'{self.execution_price_col}' price ({price}) for {ticker}. "
                f"Order: {action} {quantity} {ticker}"
            )
            return False

        # --- Calculate Commission ---
        try:
             commission = self.commission_model.calculate(quantity, price)
             if commission < 0: # Should be handled by model, but safeguard
                log.error(f"[{dt.date()}] Commission calculation returned negative value ({commission}). Using 0.")
                commission = 0.0
        except ValueError as e: # Catch potential errors from commission model
            log.error(f"[{dt.date()}] Commission calculation failed: {e}. Using 0.")
            commission = 0.0
        except Exception as e:
            log.exception(f"[{dt.date()}] Unexpected error during commission calculation: {e}. Using 0.")
            commission = 0.0


        # --- Process BUY Order ---
        if action == BUY_ACTION:
            cost = (quantity * price) + commission
            if self._cash >= cost:
                self._cash -= cost
                self._holdings[ticker] = self._holdings.get(ticker, 0) + quantity
                cost_proceeds = -cost
                log.info(
                    f"[{dt.date()}] EXEC BUY : {quantity} {ticker} @ {price:.2f} | "
                    f"Cost: {cost:.2f} (Comm: {commission:.2f}) | Cash Left: {self._cash:.2f}"
                )
            else:
                # Log clearly but don't raise InsufficientFundsError here to avoid halting loop
                log.warning(
                    f"[{dt.date()}] REJECT BUY : {quantity} {ticker} @ {price:.2f}. "
                    f"Insufficient funds. Needed {cost:.2f}, Have {self._cash:.2f}"
                )
                return False # Indicate failure

        # --- Process SELL Order ---
        elif action == SELL_ACTION:
            current_qty = self._holdings.get(ticker, 0)
            if current_qty >= quantity:
                proceeds = (quantity * price) - commission
                self._cash += proceeds
                self._holdings[ticker] -= quantity
                cost_proceeds = proceeds
                log.info(
                    f"[{dt.date()}] EXEC SELL: {quantity} {ticker} @ {price:.2f} | "
                    f"Proceeds: {proceeds:.2f} (Comm: {commission:.2f}) | Cash Left: {self._cash:.2f}"
                )
                # Clean up ticker from holdings if quantity becomes zero
                if self._holdings[ticker] == 0:
                    log.debug(f"[{dt.date()}] Holdings for {ticker} reached zero. Removing entry.")
                    del self._holdings[ticker]
            else:
                # Log clearly but don't raise InsufficientHoldingsError here
                log.warning(
                    f"[{dt.date()}] REJECT SELL: {quantity} {ticker} @ {price:.2f}. "
                    f"Insufficient holdings. Have {current_qty}, Need {quantity}"
                )
                return False # Indicate failure
        else:
            # Should be caught by Order validation, but defense-in-depth
            log.error(f"[{dt.date()}] Internal Error: Invalid order action '{action}' encountered.")
            return False

        # --- Record Successful Trade ---
        trade = Trade(
            timestamp=dt,
            ticker=ticker,
            action=action,
            quantity=quantity,
            price=price,
            commission=commission,
            cost_proceeds=cost_proceeds,
            cash_after=self._cash,
            holdings_after=self._holdings.copy() # Record state *after* trade
        )
        self._trades.append(trade)
        return True


    def _update_portfolio_value(self, dt: Timestamp) -> None:
        """
        Calculates and records the total portfolio equity at the end of the time step `dt`.

        Uses prices from `self.valuation_price_col`. Updates `self._equity_curve`.

        Raises:
            DataError: If the valuation price data is structurally missing (KeyError)
                       or if the price is NaN/non-positive for any *currently held*
                       ticker, indicating a critical valuation failure.
        """
        if self._equity_curve is None:
            # This should not happen if run() initialization is correct
            log.critical(f"[{dt.date()}] Attempted to update portfolio value but equity curve is None.")
            raise BacktesterError("Internal state error: Equity curve not initialized.")

        holdings_value: float = 0.0
        prices_used: Dict[TickerSymbol, float] = {}

        log.debug(f"[{dt.date()}] Updating portfolio value. Holdings: {self._holdings}")

        for ticker, quantity in self._holdings.items():
            if quantity == 0: # Should not happen if cleanup in _execute_order works
                log.warning(f"[{dt.date()}] Encountered zero quantity for {ticker} in holdings dict during valuation.")
                continue

            price_col_key = (self.valuation_price_col, ticker)
            price: Optional[float] = None # Declare price outside try

            try:
                # --- Step 1: Fetch Price ---
                price = self._market_data.at[dt, price_col_key]
            except KeyError:
                log.error(f"[{dt.date()}] Valuation failed: Valuation price column {price_col_key} "
                          f"structurally missing for HELD ticker {ticker} on date {dt}. Critical data issue.")
                raise DataError(f"Valuation price data structurally missing for held asset {ticker} on {dt.date()}.")
            except Exception as e: # Catch other unexpected errors during *.at* lookup
                 log.exception(f"[{dt.date()}] Unexpected error fetching valuation price for held ticker {ticker}: {e}")
                 raise DataError(f"Unexpected error getting valuation price data for {ticker} on {dt.date()}") from e

            # --- Step 2: Validate Price (outside the fetch try/except block) ---
            if price is None: # Should be logically impossible now, but defensive
                 log.critical(...)
                 raise BacktesterError(...)
            if pd.isna(price):
                log.error(f"[{dt.date()}] Valuation failed: Missing (NaN) '{self.valuation_price_col}' price for "
                          f"HELD ticker {ticker} (Qty: {quantity}). Cannot reliably value portfolio.")
                raise DataError(f"Missing valuation price for held asset {ticker} on {dt.date()}.") # Specific Error
            if price <= 0:
                 log.error(f"[{dt.date()}] Valuation failed: Non-positive '{self.valuation_price_col}' price ({price}) "
                           f"for HELD ticker {ticker} (Qty: {quantity}). Cannot reliably value portfolio.")
                 raise DataError(f"Invalid valuation price ({price}) for held asset {ticker} on {dt.date()}.") # Specific Error

            # --- Step 3: Use Validated Price ---
            holdings_value += quantity * price
            prices_used[ticker] = price

        # --- Step 4: Update Equity Curve ---
        total_equity = self._cash + holdings_value
        try:
             self._equity_curve.loc[dt, CASH_COL] = self._cash
             self._equity_curve.loc[dt, HOLDINGS_VALUE_COL] = holdings_value
             self._equity_curve.loc[dt, TOTAL_EQUITY_COL] = total_equity
        except Exception as e:
             log.exception(f"[{dt.date()}] Error updating equity curve DataFrame at loc {dt}: {e}")
             # This is serious, maybe raise internal error?
             raise BacktesterError(f"Failed to write to equity curve on {dt.date()}") from e

        log.debug(f"[{dt.date()}] EOD Valuation: Cash={self._cash:.2f}, HoldingsValue={holdings_value:.2f}, TotalEquity={total_equity:.2f}")


    def run(self) -> None:
        """
        Executes the backtest simulation loop over the configured period.

        Orchestrates data fetching, strategy signal generation, order execution,
        and portfolio valuation for each time step in the historical data.
        Populates the internal `_equity_curve` and `_trades` attributes upon
        successful completion.

        Raises:
            ConfigError: If initial configuration or date preparation fails.
            DataError: If data fetching, validation, or access during the loop fails critically.
            StrategyError: If the strategy's `generate_signals` method raises an error.
            BacktesterError: For other unrecoverable internal errors during the simulation.
        """
        log.info("--- Starting Backtest Run ---")
        if self._equity_curve is not None:
             log.warning("Backtest run initiated, but results already exist. Overwriting previous run.")
             # Reset state explicitly if re-running is allowed (design decision)
             self._cash = 0.0
             self._holdings = {}
             self._market_data = None
             self._equity_curve = None
             self._trades = []
             self._current_dt = None


        # 1. Fetch and Validate Data
        # Errors (ConfigError, DataError) raised here will halt the run.
        try:
            self._fetch_data()
        except (ConfigError, DataError) as e:
             log.error(f"Halting backtest run due to error during data preparation: {e}")
             raise # Propagate error

        # Essential check after fetch
        if self._market_data is None or self._market_data.empty:
             # Should be caught by _fetch_data, but as a final safeguard.
             log.critical("Market data is unavailable after fetch attempt. Cannot proceed.")
             raise DataError("Market data unavailable for backtest run.")

        # 2. Initialize State
        self._cash = self.initial_capital
        self._holdings = {} # Start with no holdings
        self._trades = []
        # Initialize equity curve DataFrame
        self._equity_curve = pd.DataFrame(
            index=self._market_data.index,
            columns=[CASH_COL, HOLDINGS_VALUE_COL, TOTAL_EQUITY_COL],
            dtype=float # Ensure float type
        )
        # Set initial state for the very first timestamp (before any trading)
        first_dt = self._market_data.index[0]
        self._equity_curve.loc[first_dt, CASH_COL] = self.initial_capital
        self._equity_curve.loc[first_dt, HOLDINGS_VALUE_COL] = 0.0
        self._equity_curve.loc[first_dt, TOTAL_EQUITY_COL] = self.initial_capital
        log.info(f"Initial state set: Cash={self._cash:.2f}, Holdings={self._holdings}, Initial Equity={self.initial_capital:.2f}")

        # 3. Event Loop - Iterate through each trading timestamp
        log.info(f"Starting simulation loop from {self._market_data.index.min().date()} to {self._market_data.index.max().date()}...")
        # Using itertuples is generally faster than iterrows for read-only access
        # Index=True gives us the timestamp (dt) as the first element of the tuple
        data_iterator = self._market_data.itertuples(index=True, name='MarketDataRow')

        try:
            for row in data_iterator:
                dt: Timestamp = row.Index # Get the timestamp from the tuple's index
                self._current_dt = dt
                log.debug(f"--- Processing Timestamp: {dt} ---")

                # --- A. Generate Signals ---
                # Provide data up to *including* the current dt
                # Slice efficiently using .loc with the timestamp index
                historical_data_slice: pd.DataFrame = self._market_data.loc[:dt]

                try:
                    orders_to_execute: List[Order] = self.strategy.generate_signals(
                        current_dt=dt,
                        data_slice=historical_data_slice, # Read-only access needed
                        current_holdings=self._holdings.copy(), # Pass copy for safety
                        current_cash=self._cash
                    )
                except StrategyError as e: # Catch errors explicitly raised by strategy
                     log.error(f"[{dt.date()}] StrategyError occurred: {e}", exc_info=True)
                     raise # Re-raise StrategyError to halt the run
                except Exception as e: # Catch unexpected errors within strategy
                     log.exception(f"[{dt.date()}] Unhandled exception in strategy.generate_signals: {e}")
                     # Wrap in StrategyError to indicate source and halt run
                     raise StrategyError(f"Unhandled exception in strategy on {dt.date()}: {e}") from e


                # --- B. Execute Orders ---
                # Orders generated based on data up to `dt` are simulated to execute *at* `dt`
                # using the configured execution price (e.g., Open price of `dt`).
                if orders_to_execute:
                    log.debug(f"[{dt.date()}] {len(orders_to_execute)} order(s) generated by strategy.")
                    for order in orders_to_execute:
                        # Validate order (ticker tracked, positive quantity already handled by Order)
                        if order.ticker not in self.tickers:
                            log.warning(f"[{dt.date()}] Strategy generated order for untracked ticker "
                                        f"'{order.ticker}'. Skipping order: {order.action} {order.quantity}")
                            continue

                        try:
                             # _execute_order returns True on success, False on failure (e.g., funds)
                             # It raises DataError on critical data issues
                             self._execute_order(dt, order)
                             # Continue processing other orders even if one fails due to funds/holdings
                        except DataError as e:
                            # DataError during execution is critical - likely data missing/corrupt
                             log.error(f"[{dt.date()}] Halting run due to DataError during order execution: {e}")
                             raise # Re-raise to stop simulation


                # --- C. Update Portfolio Value (Mark-to-Market) ---
                # Uses valuation price (e.g., Close price of `dt`) *after* any trades at `dt` occurred.
                try:
                     # DataError raised here halts the run (critical valuation failure).
                    self._update_portfolio_value(dt)
                except DataError as e:
                    log.error(f"[{dt.date()}] Halting run due to DataError during portfolio valuation: {e}")
                    raise # Re-raise to stop simulation

            log.info("--- Simulation loop completed successfully ---")

        except (ConfigError, DataError, StrategyError, BacktesterError) as e:
            # Catch errors raised explicitly during the loop or initialization
            log.error(f"Backtest run terminated prematurely due to error: {type(e).__name__} - {e}")
            # Clear potentially incomplete results to indicate failure
            self._equity_curve = None
            self._trades = []
            raise # Re-raise the caught exception

        except Exception as e:
            # Catch any other unexpected errors during the loop
            log.exception(f"[{self._current_dt.date() if self._current_dt else 'N/A'}] "
                          f"An unexpected critical error occurred during the simulation loop.")
            # Clear results and raise a generic BacktesterError
            self._equity_curve = None
            self._trades = []
            raise BacktesterError("Unexpected critical error during simulation.") from e


        # --- Final state log ---
        if self._equity_curve is not None and not self._equity_curve.empty:
             final_equity = self._equity_curve[TOTAL_EQUITY_COL].iloc[-1]
             log.info(f"Final Portfolio Equity: {final_equity:.2f}")
             log.info(f"Total Trades Executed: {len(self._trades)}")
        else:
             # Should not happen if loop completed, but safeguard log
             log.warning("Backtest run finished, but equity curve appears empty or None.")


    def get_results(self) -> Tuple[pd.DataFrame, List[Trade]]:
        """
        Returns the results of a completed backtest run.

        It's recommended to call this only after `run()` has executed successfully.

        Returns:
            Tuple[pd.DataFrame, List[Trade]]: A tuple containing:
                - A *copy* of the equity curve DataFrame (index: Timestamp,
                  columns: 'Cash', 'Holdings_Value', 'Total_Equity'). Returns an
                  empty DataFrame if the run failed or did not produce results.
                - A *copy* of the list of executed Trade objects. Returns an empty
                  list if the run failed or no trades occurred.

        """
        if self._equity_curve is None:
            log.warning("Attempted to get results, but backtest did not run successfully or "
                        "produced no equity curve. Returning empty results.")
            # Return empty structures consistent with the types
            return pd.DataFrame(columns=[CASH_COL, HOLDINGS_VALUE_COL, TOTAL_EQUITY_COL]), []

        log.info("Returning backtest results (equity curve and trades list).")
        # Return copies to prevent external modification of internal state
        return self.equity_curve.copy(), self.trades.copy()

    # --- Property accessors for potentially useful read-only state ---
    @property
    def equity_curve(self) -> Optional[pd.DataFrame]:
        """Optional[pd.DataFrame]: Read-only access to the equity curve DataFrame. Returns None if backtest hasn't run successfully."""
        return self._equity_curve

    @property
    def trades(self) -> List[Trade]:
        """List[Trade]: Read-only access to the list of executed trades."""
        return self._trades

    @property
    def market_data(self) -> Optional[pd.DataFrame]:
         """Optional[pd.DataFrame]: Read-only access to the fetched market data. Returns None if data hasn't been fetched."""
         return self._market_data

    @property
    def actual_start_date(self) -> Optional[date]:
        """Optional[date]: The actual start date of the market data used, determined after fetching."""
        return self._actual_start_date

    @property
    def actual_end_date(self) -> Optional[date]:
        """Optional[date]: The actual end date of the market data used, determined after fetching."""
        return self._actual_end_date